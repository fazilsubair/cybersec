import re

# Function to swap characters at positions i1 and i2 in the address list
def swap_chars(addr, i1, i2):
    addr[i1], addr[i2] = addr[i2], addr[i1]
    return addr

# Function to apply a series of predefined swaps to the address list
def apply_swaps(addr):
    swaps = [(0, 12), (14, 26), (4, 8), (20, 23)]  # List of tuples defining the swaps
    for i1, i2 in swaps:
        addr = swap_chars(addr, i1, i2)
    return addr

# Function to reverse the transformation applied to the encrypted string
def reverse_transform(enc_str, key):
    xor_pos = [2, 4, 6, 8, 11, 13]  # Positions to XOR with the key
    swap_pos = [12, 5, 2, 7, 4, 9, 6, 10, 8, 0, 3, 11, 1, 13]  # New positions for swapping

    # XOR specific positions in the encrypted string with the key
    enc_str = [chr(ord(c) ^ key) if i in xor_pos else c for i, c in enumerate(enc_str)]

    # Apply the swap positions 8 times
    for _ in range(8):
        enc_str = [enc_str[i] for i in swap_pos]

    return ''.join(enc_str)

# Function to decrypt the flag by reversing the transformation on two halves
def decrypt_flag(enc_str):
    f1, f2 = enc_str[:14], enc_str[14:]  # Split the encrypted string into two parts
    d1 = reverse_transform(f1, 2)  # Reverse transform the first part with key 2
    d2 = reverse_transform(f2, 3)  # Reverse transform the second part with key 3
    return ''.join(apply_swaps(list(d1 + d2)))  # Apply swaps to the combined parts

# Read the binary file and XOR each byte with 0xab, then write to a new file
with open("file.bin", "rb") as fp, open("file_bin", "wb") as out_fp:
    out_fp.write(bytes([byte[0] ^ 0xab for byte in iter(lambda: fp.read(1), b'')]))

# Read the transformed file and extract the encrypted flag using a regex pattern
with open("file_bin", "rb") as f:
    enc_flag = re.search(rb'([ -~]{28}\x00)', f.read()).group(0).decode('ascii', errors='ignore')

# Decrypt the flag and print it
dec_flag = decrypt_flag(enc_flag)
print(f"Flag: HTB{{{dec_flag}}}")
